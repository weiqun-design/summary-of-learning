URL编码
URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。
但如果URL中包含中文、日文这些非ASCII字符。不要紧，URL编码有一套规则：
如果字符是A~Z，a~z，0~9以及-、_、.、*，则保持不变；
如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示

Base64编码
Base64编码是对二进制数据进行编码，表示成文本格式。
Base64编码可以把任意长度的二进制数据变为纯文本，且只包含A~Z、a~z、0~9、+、/、=这些字符。
它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。
因为6位整数的范围总是0~63，所以，能用64个字符表示：字符A~Z对应索引0~25，字符a~z对应索引26~51，字符0~9对应索引52~61，最后两个索引62、63分别用字符+和/表示

如果输入的byte[]数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。
实际上，因为编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。Base64编码的时候可以用withoutPadding()去掉=，解码出来的结果是一样的如果输入的byte[]数组长度不是3的整数倍肿么办？
这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。
实际上，因为编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。Base64编码的时候可以用withoutPadding()去掉=，解码出来的结果是一样的

Hash算法
哈希算法又称摘要算法，它的作用是对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
哈希算法最重要的特定就是：相同的输入一定得到相同的输出；不同的输入大概率得到不同的输出。
哈希碰撞是指，两个不同的输入得到了相同的输出.
碰撞是不可避免的。
一个安全的哈希算法必须满足：
碰撞概率低，不能猜测输出。
常用的哈希算法：
算法                       输出长度（位）                    输出长度（字节）
MD5                       128 bits                         16 bytes
SHA-1                     160 bits                         20 bytes
RipeMD-160                160 bits                         20 bytes
SHA-256                   256 bits                         32 bytes
SHA-512                   512 bits                         64 bytes

使用哈希口令时，还要注意防止彩虹表攻击，即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法
称之为加盐（salt）;

HmacMD5可以看作带有一个安全的key的MD5，使用HmacMD5而不是用MD5加salt，又如下好处：
HmacMD5使用的key长度是64字节，更安全；
Hmac是标注算法，同样适用于SHA-1等其他哈希算法
Hmac输出的和原有的哈希算法长度一致。

对称加密算法就是传统的用一个密码进行加密和解密。

在软件开发中，常用的对称加密算法有：

算法	    密钥长度	            工作模式	                    填充模式
DES	     56/64	       ECB/CBC/PCBC/CTR/...	     NoPadding/PKCS5Padding/...
AES	128/192/256	       ECB/CBC/PCBC/CTR/...	     NoPadding/PKCS5Padding/PKCS7Padding/...
IDEA	128	           ECB	                     PKCS5Padding/PKCS7Padding/...

秘钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有
填充模式，但是通常我们只需要挑选常用的使用就可以了。
DES算法由于秘钥过短，可以在短时间内暴力破解，所以现在已经不安全了。AES算法是目前应用最广泛的加密算法。


口令加密算法
平时使用的加密软件，输入6位、8位都可以，实际上用户输入的口令并不能直接作为AES的秘钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令
一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算处真正的秘钥，再进行加密。
PEB就是password based encryption的缩写
key = generate(userPassword, secureRandomPassword)
PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；
Key通过口令和安全的随机salt计算得出，大大提高了安全性；
PBE算法内部使用的仍然是标准对称加密算法（例如AES）


秘钥交换算法
对称加密算法解决了数据加密的问题，新的问题是秘钥交换算法DH算法；Diffie-Hellman算法产生了
DH算法解决了秘钥在双方不直接传递秘钥得到情况下，完成秘钥交换
算法过程：
1. 甲首先选择一个素数p，底数g，随机数a，然后计算A=g^a mod p ，然后甲发送p，g和A给乙。
2. 乙收到后，选择一个随机数b，然后计算B=g^b mod p 乙再计算s=A^b mod p,
3. 乙把B发送给甲，甲计算s = B^a mod p，计算结果与乙计算的结果一样




非对称加密算法
从DH算法可以得出，公钥和私钥组成的秘钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。
非对称加密就是加密和解密使用的不是相同的秘钥：只有同一个公钥-私钥对才能正常加解密。
非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman发明的。

非对称加密相比对称加密的显著优点在于，对称加密需要协商秘钥，而非堆成加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要
N个秘钥对，每个人只管理自己的秘钥对。而使用对称加密，则需要N*（N-1）/2个秘钥，因此每个人需要管理N-1个秘钥，秘钥管理难度大，而且非常容易泄漏。
既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。

所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：
小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；
小红用自己的RSA私钥解密得到AES口令；
双方使用这个共享的AES口令用AES加密通信。











